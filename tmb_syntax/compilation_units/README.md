## Using multiple compilation units with TMB

Compilation time may be an issue when working with bigger projects in
TMB because the entire project needs re-compilation whenever the TMB
model code is changed. To address this problem one can split a TMB
project into several compilation units that can be updated
individually without re-compiling other units.

We will use
[tmb_examples/adaptive_integration.cpp](../../tmb_examples/adaptive_integration.cpp)
as example because it takes fairly long time to compile. We split the
file into three new units:

| Compilation unit          | Description                                             |
|---------------------------|---------------------------------------------------------|
|`adaptive_integration.cpp` | Objective function (the main file)                      |
|`distrib.cpp`              | Special function using adaptive integration             |
|`TMB.cpp`                  | TMB core functions (AD library and R interfacing code)  |

In addition we need header files `distrib.h` and `TMB.h` to include in
the main file. Note that the `*.h` extension is required for C++
headers in R packages.

### Generating the files

The main file [adaptive_integration.cpp](./adaptive_integration.cpp)
is created by copy-pasting the objective function and adding the two
header includes `TMB.h` and `distrib.h`.

The Files [TMB.cpp](./TMB.cpp) and [TMB.h](./TMB.h) are equally easy
to generate. One includes `<TMB.hpp>` preceded by
`<tmb_enable_precompile.hpp>`, the other preceded by
`<tmb_enable_header_only.hpp>`. In fact these two files can be
autogenerated by running from R `TMB::precompile(get.header=TRUE,
all=FALSE)`. As a side note, the option `all=TRUE` precompiles a
bigger portion of TMB which is relevent for projects using the
namespace 'density'.

The files [distrib.cpp](./distrib.cpp) and [distrib.h](./distrib.h)
are a bit more tricky. The special function namespace `my_atomic` is
copy-pasted to `distrib.h`. In addition a switch `DISTRIB_PRECOMPILE`
is added *after* including `TMB.h`. The switch implicitly controls the
expansion of the TMB code generation macros (in this case
`TMB_BIND_ATOMIC`).  Finally, `distrib.cpp` sets the precompile switch
and includes the header.

### Prepare the setup

The approach described here is especially relevant for R packages
linking to TMB.  When compiling R packages, no TMB specific
preprocessor flags are set by default. To mimic this behaviour, we
start by overloading the TMB compile function accordingly:

```{r}
compile <- TMB::compile
formals(compile)$safebounds <- FALSE
formals(compile)$safeunload <- FALSE
formals(compile)$libtmb <- FALSE
formals(compile)$libinit <- FALSE
```

### Testing compilation

For comparison it may be useful to test the compilation time of the
original (unsplit) model code:

```r
system.time(compile("../../tmb_examples/adaptive_integration.cpp"))
```

We skip this step here, and instead turn to compiling the project. The
project consists of the files

```{r}
project <- c("adaptive_integration.cpp", "distrib.cpp", "TMB.cpp")
```

First compilation takes a while...

```{r}
system.time(compile(project))
```

When working with the project it is expected that
`adaptive_integration.cpp` is updated frequently, `distrib.cpp` is
updated rarely while `TMB.cpp` is never updated. Let's update the main
file (or remove the corresponding object file) and recompile:

```{r}
file.remove("adaptive_integration.o")
system.time(compile(project))
```

This should be much faster than compiling the single file project from
scratch.

### Testing that the compiled code works

We can now run the model:

```{r}
source("../../tmb_examples/adaptive_integration.R",echo=TRUE)
```
