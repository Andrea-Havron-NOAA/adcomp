#ifndef HAVE_VECTORIZE_HPP
#define HAVE_VECTORIZE_HPP
// Autogenerated - do not edit by hand !

namespace TMBad {

typedef global::ad_range ad_range;

template <class Type, bool S0 = 0, bool S1 = 0>
struct Vectorized {
  Type x;

  static constexpr bool stride(bool j) {
    if (j)
      return S1;
    else
      return S0;
  }
  operator Type() { return x; }
  Vectorized(Type x) : x(x) {}
  Vectorized() {}
};

template <class Type, bool S0, bool S1>
struct ForwardArgs<Vectorized<Type, S0, S1> > : ForwardArgs<Type> {
  typedef Vectorized<Type, S0, S1> T;
  typedef ForwardArgs<Type> Base;
  size_t k;
  /** \brief j'th input variable of this operator */
  Type x(bool j) const {
    return Base::values[Base::input(j) + k * T::stride(j)];
  }
  /** \brief j'th output variable of this operator */
  Type &y(Index j) { return Base::values[Base::output(j) + k]; }
  ForwardArgs(const Base &x) : Base(x) {}
};

template <class Type, bool S0, bool S1>
struct ReverseArgs<Vectorized<Type, S0, S1> > : ReverseArgs<Type> {
  typedef Vectorized<Type, S0, S1> T;
  typedef ReverseArgs<Type> Base;
  size_t k;
  /** \brief j'th input variable of this operator */
  Type x(bool j) const {
    return Base::values[Base::input(j) + k * T::stride(j)];
  }
  /** \brief j'th output variable of this operator */
  Type y(Index j) const { return Base::values[Base::output(j) + k]; }
  /** \brief Partial derivative of end result wrt. j'th input variable of
      this operator */
  Type &dx(bool j) const {
    return Base::derivs[Base::input(j) + k * T::stride(j)];
  }
  /** \brief Partial derivative of end result wrt. j'th output variable of
      this operator */
  Type dy(Index j) const { return Base::derivs[Base::output(j) + k]; }
  ReverseArgs(const Base &x) : Base(x) {}
};

struct VSumOp : global::DynamicOperator<1, 1> {
  static const bool is_linear = true;
  size_t n;
  VSumOp(size_t n);
  template <class Type>
  void forward(ForwardArgs<Type> &args) {
    const Type *x = args.x_ptr(0);
    Type &y = args.y(0);
    y = 0;
    for (size_t i = 0; i < n; i++) y += x[i];
  }
  template <class Type>
  void reverse(ReverseArgs<Type> &args) {
    Type *dx = args.dx_ptr(0);
    const Type &dy = args.dy(0);
    for (size_t i = 0; i < n; i++) dx[i] += dy;
  }

  void dependencies(Args<> &args, Dependencies &dep) const;
  static const bool have_dependencies = true;
  /** \brief This operator **has** implicit dependencies */
  static const bool implicit_dependencies = true;
  /** \brief It is **not* safe to remap the inputs of this operator */
  static const bool allow_remap = false;
  void forward(ForwardArgs<Writer> &args);
  void reverse(ReverseArgs<Writer> &args);
  const char *op_name();
};

ad_aug sum(ad_range x);

ad_range operator/(ad_range x, ad_range y);
ad_range operator*(ad_range x, ad_range y);
ad_range operator+(ad_range x, ad_range y);
ad_range operator-(ad_range x, ad_range y);
ad_range operator-(ad_range x);
template <class dummy = void>
ad_range &operator+=(ad_range &x, ad_range y) {
  if (x.size() < y.size()) y = ad_range(sum(y), 1);
  if (x.identicalZero())
    x = y;
  else
    x = x + y;
  return x;
}
template <class dummy = void>
ad_range &operator-=(ad_range &x, ad_range y) {
  if (x.size() < y.size()) y = ad_range(sum(y), 1);
  if (x.identicalZero())
    x = -y;
  else
    x = x - y;
  return x;
}

template <class Operator, bool S0 = false, bool S1 = false>
struct Vectorize : global::DynamicOperator<Operator::ninput, -1> {
  size_t n;
  static const bool have_input_size_output_size = true;
  Index input_size() const { return Operator::ninput; }
  Index output_size() const { return this->n; }
  Vectorize(size_t n) : n(n) {}
  void forward(ForwardArgs<Scalar> &args) {
    ForwardArgs<Vectorized<Scalar, S0, S1> > vargs(args);
    typename global::CPL<Operator>::type Op;
    for (vargs.k = 0; vargs.k < n; vargs.k++) {
      Op.forward(vargs);
    }
  }
  void forward(ForwardArgs<Replay> &args) {
    ad_range x0(args.x_ptr(0), (S0 ? n : 1));
    ad_range x1;
    if (Operator::ninput > 1) {
      x1 = ad_range(args.x_ptr(1), (S1 ? n : 1));
    }
    global::Complete<Vectorize> F(*this);
    ad_range y = F(x0, x1);
    for (size_t i = 0; i < y.size(); i++) args.y(i) = y[i];
  }
  void reverse(ReverseArgs<Scalar> &args) {
    ReverseArgs<Vectorized<Scalar, S0, S1> > vargs(args);
    typename global::CPL<Operator>::type Op;
    for (vargs.k = 0; vargs.k < n; vargs.k++) {
      Op.reverse(vargs);
    }
  }
  void reverse(ReverseArgs<Replay> &args) {
    std::vector<ad_range> v;
    std::vector<ad_range> d;
    std::vector<Index> i;

    v.push_back(ad_range(args.x_ptr(0), (S0 ? n : 1)));
    d.push_back(ad_range(args.dx_ptr(0), (S0 ? n : 1), true));
    i.push_back(i.size());
    if (Operator::ninput > 1) {
      v.push_back(ad_range(args.x_ptr(1), (S1 ? n : 1)));
      d.push_back(ad_range(args.dx_ptr(1), (S1 ? n : 1), true));
      i.push_back(i.size());
    }

    v.push_back(ad_range(args.y_ptr(0), n));
    d.push_back(ad_range(args.dy_ptr(0), n));

    ReverseArgs<ad_range> vargs(i, v, d);

    vargs.ptr.first = 0;
    vargs.ptr.second = Operator::ninput;
    typename global::CPL<Operator>::type Op;
    Op.reverse(vargs);

    for (size_t i = 0; i < vargs.dx(0).size(); i++)
      args.dx_ptr(0)[i] = vargs.dx(0)[i];
    if (Operator::ninput > 1) {
      for (size_t i = 0; i < vargs.dx(1).size(); i++)
        args.dx_ptr(1)[i] = vargs.dx(1)[i];
    }
  }

  void dependencies(Args<> &args, Dependencies &dep) const {
    dep.add_segment(args.input(0), (S0 ? n : 1));
    if (Operator::ninput == 2) {
      dep.add_segment(args.input(1), (S1 ? n : 1));
    }
  }
  static const bool have_dependencies = true;
  /** \brief This operator **has** implicit dependencies */
  static const bool implicit_dependencies = true;
  /** \brief It is **not* safe to remap the inputs of this operator */
  static const bool allow_remap = false;
  void forward(ForwardArgs<Writer> &args) { TMBAD_ASSERT(false); }
  void reverse(ReverseArgs<Writer> &args) { TMBAD_ASSERT(false); }
  const char *op_name() {
    global::Complete<Operator> Op;
    static const std::string name = std::string("V") + Op.op_name();
    return name.c_str();
  }
  Vectorize(const ad_range &x, const ad_range &y)
      : n(std::max(x.size(), y.size())) {}
};
ad_range operator/(ad_range x, ad_range y);
ad_range operator/(ad_range x, ad_aug y);
ad_range operator/(ad_aug x, ad_range y);
ad_range operator*(ad_range x, ad_range y);
ad_range operator*(ad_range x, ad_aug y);
ad_range operator*(ad_aug x, ad_range y);
ad_range operator+(ad_range x, ad_range y);
ad_range operator+(ad_range x, ad_aug y);
ad_range operator+(ad_aug x, ad_range y);
ad_range operator-(ad_range x, ad_range y);
ad_range operator-(ad_range x, ad_aug y);
ad_range operator-(ad_aug x, ad_range y);
ad_range operator-(ad_range x);

}  // namespace TMBad
#endif  // HAVE_VECTORIZE_HPP
