<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TMB Documentation: atomic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.7.22</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atomic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace with special functions and derivatives.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1AtomicGlobal.html">AtomicGlobal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For backwards compatibility with CppAD.  <a href="structatomic_1_1AtomicGlobal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1AtomicLocal.html">AtomicLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface to checkpointing using <a class="el" href="namespaceTMBad.html" title="Automatic differentiation library designed for TMB. ">TMBad</a>.  <a href="structatomic_1_1AtomicLocal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gac09966696ad9685dc8047d6c582bc0ae">expm</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gac09966696ad9685dc8047d6c582bc0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="group__matrix__functions.html#gac09966696ad9685dc8047d6c582bc0ae">More...</a><br /></td></tr>
<tr class="separator:gac09966696ad9685dc8047d6c582bc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5555ee5c905915a566d47d7f2830424"><td class="memTemplParams" colspan="2">
template&lt;class Type &gt; </td></tr>
<tr class="memitem:gae5555ee5c905915a566d47d7f2830424"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gae5555ee5c905915a566d47d7f2830424">logdet</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gae5555ee5c905915a566d47d7f2830424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log-determinant of positive definite matrix. <br /></td></tr>
<tr class="separator:gae5555ee5c905915a566d47d7f2830424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inverse.  <a href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">More...</a><br /></td></tr>
<tr class="separator:gacf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06aed041873dea3426da0d0bac628583"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga06aed041873dea3426da0d0bac628583"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga06aed041873dea3426da0d0bac628583">matinvpd</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, Type &amp;<a class="el" href="group__matrix__functions.html#gae5555ee5c905915a566d47d7f2830424">logdet</a>)</td></tr>
<tr class="memdesc:ga06aed041873dea3426da0d0bac628583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inverse and determinant.  <a href="group__matrix__functions.html#ga06aed041873dea3426da0d0bac628583">More...</a><br /></td></tr>
<tr class="separator:ga06aed041873dea3426da0d0bac628583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481538cdd18f419396ee65eaec62c0ba"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga481538cdd18f419396ee65eaec62c0ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; y)</td></tr>
<tr class="memdesc:ga481538cdd18f419396ee65eaec62c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply.  <a href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">More...</a><br /></td></tr>
<tr class="separator:ga481538cdd18f419396ee65eaec62c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4fa812a522e0eccb59e88dd89dd18d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#aab4fa812a522e0eccb59e88dd89dd18d">TMB_ATOMIC_STATIC_FUNCTION</a> (pnorm1, 1, ty[0]=Rmath::Rf_pnorm5(tx[0], 0, 1, 1, 0);, px[0]=dnorm1(tx[0]) *py[0];) TMB_ATOMIC_STATIC_FUNCTION(qnorm1</td></tr>
<tr class="memdesc:aab4fa812a522e0eccb59e88dd89dd18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'.  <a href="#aab4fa812a522e0eccb59e88dd89dd18d">More...</a><br /></td></tr>
<tr class="separator:aab4fa812a522e0eccb59e88dd89dd18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f82fc0d0a030e53d136a6a14c804f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a67f82fc0d0a030e53d136a6a14c804f1">TMB_ATOMIC_STATIC_FUNCTION</a> (D_incpl_gamma_shape, 4, ty[0]=Rmath::D_incpl_gamma_shape(tx[0], tx[1], tx[2], tx[3]);, px[0]=exp(-tx[0]+(tx[1]-Type(1.0)) *log(tx[0])+tx[3]) *pow(log(tx[0]), tx[2]) *py[0];Type tx_[4];tx_[0]=tx[0];tx_[1]=tx[1];tx_[2]=tx[2]+Type(1.0);tx_[3]=tx[3];px[1]=D_incpl_gamma_shape(tx_) *py[0];px[2]=Type(0);px[3]=ty[0] *py[0];) TMB_ATOMIC_STATIC_FUNCTION(inv_incpl_gamma</td></tr>
<tr class="memdesc:a67f82fc0d0a030e53d136a6a14c804f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p><p class="formulaDsp">
\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]
</p>
<p> where the 4 input parameters are passed as a vector \(x=(y,\lambda,n,c)\). Note that the normalized incomplete gamma function is obtained as the special case \(n=0\) and \(c=-\log \Gamma(\lambda)\). Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}\).  <a href="#a67f82fc0d0a030e53d136a6a14c804f1">More...</a><br /></td></tr>
<tr class="separator:a67f82fc0d0a030e53d136a6a14c804f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5be1ffa66c34b67111f343e47fb3c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a8a5be1ffa66c34b67111f343e47fb3c9">TMB_ATOMIC_STATIC_FUNCTION</a> (D_lgamma, 2, ty[0]=Rmath::D_lgamma(tx[0], tx[1]);, Type tx_[2];tx_[0]=tx[0];tx_[1]=tx[1]+Type(1.0);px[0]=D_lgamma(tx_) *py[0];px[1]=Type(0);) TMB_ATOMIC_STATIC_FUNCTION(<a class="el" href="group__R__style__distribution.html#ga21965e84a53d083256382b7eeb0383e7">ppois</a></td></tr>
<tr class="memdesc:a8a5be1ffa66c34b67111f343e47fb3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of the n'th order derivative of the log gamma function. </p><p class="formulaDsp">
\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]
</p>
<p> where the 2 input parameters are passed as a vector \(x=(\lambda,n)\). The special case \(n=0\) gives the log gamma function.  <a href="#a8a5be1ffa66c34b67111f343e47fb3c9">More...</a><br /></td></tr>
<tr class="separator:a8a5be1ffa66c34b67111f343e47fb3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e546d4694a98ec59a15242d520df38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a80e546d4694a98ec59a15242d520df38">TMB_ATOMIC_STATIC_FUNCTION</a> (bessel_k_10, 2, ty[0]=Rmath::Rf_bessel_k(tx[0], tx[1], 1.0);, Type value=ty[0];Type x=tx[0];Type nu=tx[1];Type arg[2];arg[0]=x;arg[1]=nu+Type(1);px[0]=(-bessel_k_10(arg)+value *(nu/x)) *py[0];px[1]=Type(0);) TMB_ATOMIC_STATIC_FUNCTION(bessel_i_10</td></tr>
<tr class="memdesc:a80e546d4694a98ec59a15242d520df38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of \(besselK(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\).  <a href="#a80e546d4694a98ec59a15242d520df38">More...</a><br /></td></tr>
<tr class="separator:a80e546d4694a98ec59a15242d520df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f02597375de42ca19bcaeff3190938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#af9f02597375de42ca19bcaeff3190938">TMB_ATOMIC_VECTOR_FUNCTION</a> (<a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>, CppAD::Integer(tx[0]) *CppAD::Integer(tx[1]), typedef TypeDefs&lt; double &gt;::MapMatrix MapMatrix_t;typedef TypeDefs&lt; double &gt;::ConstMapMatrix ConstMapMatrix_t;int n1=CppAD::Integer(tx[0]);int n3=CppAD::Integer(tx[1]);int n2=(n1+n3 &gt; 0 ?(tx.size() - 2)/(n1+n3) :0);ConstMapMatrix_t X(&amp;tx[2], n1, n2);ConstMapMatrix_t Y(&amp;tx[2+n1 *n2], n2, n3);MapMatrix_t Z(&amp;ty[0], n1, n3);Z=X *Y;, typedef typename TypeDefs&lt; Type &gt;::MapMatrix MapMatrix_t;int n1=CppAD::Integer(tx[0]);int n3=CppAD::Integer(tx[1]);int n2=(n1+n3 &gt; 0 ?(tx.size() - 2)/(n1+n3) :0);<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; Xt=vec2mat(tx, n1, n2, 2).transpose();<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; Yt=vec2mat(tx, n2, n3, 2+n1 *n2).transpose();<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; W=vec2mat(py, n1, n3);MapMatrix_t res1(&amp;px[2], n1, n2);MapMatrix_t res2(&amp;px[2+n1 *n2], n2, n3);res1=<a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>(W, Yt);res2=<a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>(Xt, W);px[0]=0;px[1]=0;) TMB_ATOMIC_VECTOR_FUNCTION(<a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a></td></tr>
<tr class="memdesc:af9f02597375de42ca19bcaeff3190938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix.  <a href="#af9f02597375de42ca19bcaeff3190938">More...</a><br /></td></tr>
<tr class="separator:af9f02597375de42ca19bcaeff3190938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215bba00f5e746637c35e56e66be2cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a7215bba00f5e746637c35e56e66be2cf">TMB_ATOMIC_VECTOR_FUNCTION</a> (<a class="el" href="group__matrix__functions.html#gae5555ee5c905915a566d47d7f2830424">logdet</a>, 1, int n=sqrt((double) tx.size());<a class="el" href="structmatrix.html">matrix</a>&lt; double &gt; X=vec2mat(tx, n, n);<a class="el" href="structmatrix.html">matrix</a>&lt; double &gt; LU=X.lu().matrixLU();<a class="el" href="structvector.html">vector</a>&lt; double &gt; LUdiag=LU.diagonal();double res=LUdiag.abs().log().<a class="el" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>();ty[0]=res;, CppAD::vector&lt; Type &gt; invX=<a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a>(tx);for(size_t i=0;i&lt; tx.size();i++) px[i]=invX[i] *py[0];) TMB_ATOMIC_VECTOR_FUNCTION(invpd</td></tr>
<tr class="memdesc:a7215bba00f5e746637c35e56e66be2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of log determinant of positive definite n-by-n matrix.  <a href="#a7215bba00f5e746637c35e56e66be2cf">More...</a><br /></td></tr>
<tr class="separator:a7215bba00f5e746637c35e56e66be2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace with special functions and derivatives. </p>
<p>This namespace extends the 'derivatives table' of CppAD.</p><ul>
<li>R's special math library is extended with derivatives in cases where symbolic derivatives are available. These special functions are often iterative and therefore difficult to implement with AD types. Instead, we code the derivatives based on the double versions available from R. This approach requires fewer code lines, and has the benefit of obtaining the same high accuracy as R's math functions.</li>
<li>Some matrix operations are extended with derivatives. This greatly reduces the AD memory usage. Furthermore, these atomic operations can be linked to a performance library by setting preprocesor flag EIGEN_USE_BLAS.</li>
<li>New symbols can be added by advanced users. First option is to code the reverse mode derivatives by hand using the TMB_ATOMIC_VECTOR_FUNCTION macro, see source code for examples. Second option is to generate reverse mode derivatives automatically using the macro REGISTER_ATOMIC. </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aab4fa812a522e0eccb59e88dd89dd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4fa812a522e0eccb59e88dd89dd18d">&sect;&nbsp;</a></span>TMB_ATOMIC_STATIC_FUNCTION() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_STATIC_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">pnorm1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ty&#160;</td>
          <td class="paramname">[0] = <code>Rmath::Rf_pnorm5(tx[0],0,1,1,0);</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">px&#160;</td>
          <td class="paramname">[0] = <code>dnorm1(tx[0])&#160;*&#160;py[0];</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1.Atomic version of standard normal quantile function. Derivative is expressed through 'dnorm1'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a67f82fc0d0a030e53d136a6a14c804f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f82fc0d0a030e53d136a6a14c804f1">&sect;&nbsp;</a></span>TMB_ATOMIC_STATIC_FUNCTION() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_STATIC_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">D_incpl_gamma_shape&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">4&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ty&#160;</td>
          <td class="paramname">[0] = <code>Rmath::D_incpl_gamma_shape(tx[0],tx[1],tx[2],tx[3]);</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">px&#160;</td>
          <td class="paramname">[0] = <code>exp(&#160;-tx[0]&#160;+&#160;(tx[1]-Type(1.0))&#160;*&#160;log(tx[0])&#160;+&#160;tx[3]&#160;)&#160;*&#160;pow(log(tx[0]),tx[2])&#160;*&#160;py[0];&#160;Type&#160;tx_[4];&#160;tx_[0]&#160;=&#160;tx[0];&#160;tx_[1]&#160;=&#160;tx[1];&#160;tx_[2]&#160;=&#160;tx[2]&#160;+&#160;Type(1.0);&#160;&#160;tx_[3]&#160;=&#160;tx[3];&#160;px[1]&#160;=&#160;D_incpl_gamma_shape(tx_)&#160;*&#160;py[0];&#160;px[2]&#160;=&#160;Type(0);&#160;px[3]&#160;=&#160;ty[0]&#160;*&#160;py[0];</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p><p class="formulaDsp">
\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]
</p>
<p> where the 4 input parameters are passed as a vector \(x=(y,\lambda,n,c)\). Note that the normalized incomplete gamma function is obtained as the special case \(n=0\) and \(c=-\log \Gamma(\lambda)\). Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}\). </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1.Atomic version of inverse of scaled incomplete gamma function. Given \(z\) find \(y\) such that <p class="formulaDsp">
\[ z = \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \:dt \]
</p>
 where the 3 input parameters are passed as a vector \(x=(z,\lambda,c)\). The special case \(c=-\log \Gamma(\lambda)\) gives the inverse normalized incomplete gamma function. Valid parameter range: \(x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{R}\). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a8a5be1ffa66c34b67111f343e47fb3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5be1ffa66c34b67111f343e47fb3c9">&sect;&nbsp;</a></span>TMB_ATOMIC_STATIC_FUNCTION() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_STATIC_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">D_lgamma&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ty&#160;</td>
          <td class="paramname">[0] = <code>Rmath::D_lgamma(tx[0],tx[1]);</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type tx_;&#160;</td>
          <td class="paramname"><em>tx_</em>[2][0] = <code>tx[0];&#160;tx_[1]=tx[1]+Type(1.0);&#160;px[0]&#160;=&#160;D_lgamma(tx_)&#160;*&#160;py[0];&#160;px[1]&#160;=&#160;Type(0);</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of the n'th order derivative of the log gamma function. </p><p class="formulaDsp">
\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]
</p>
<p> where the 2 input parameters are passed as a vector \(x=(\lambda,n)\). The special case \(n=0\) gives the log gamma function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1.Atomic version of poisson cdf \(ppois(n,\lambda)\). Valid parameter range: \(x =(n,\lambda) \in \mathbb{N}_0\times\mathbb{R}_+\). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="a80e546d4694a98ec59a15242d520df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e546d4694a98ec59a15242d520df38">&sect;&nbsp;</a></span>TMB_ATOMIC_STATIC_FUNCTION() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_STATIC_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">bessel_k_10&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ty&#160;</td>
          <td class="paramname">[0] = <code>Rmath::Rf_bessel_k(tx[0],&#160;tx[1],&#160;1.0&#160;);</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em> = <code>ty[0];&#160;Type&#160;x&#160;=&#160;tx[0];&#160;Type&#160;nu&#160;=&#160;tx[1];&#160;Type&#160;arg[2];&#160;arg[0]&#160;=&#160;x;&#160;arg[1]&#160;=&#160;nu&#160;+&#160;Type(1);&#160;px[0]&#160;=&#160;(&#160;-bessel_k_10(arg)&#160;+&#160;value&#160;*&#160;(nu&#160;/&#160;x)&#160;)&#160;*&#160;py[0];&#160;px[1]&#160;=&#160;Type(0);</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of \(besselK(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\). </p>
<dl class="section note"><dt>Note</dt><dd>This atomic function does not handle the derivative wrt. \(\nu\). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1.Atomic version of \(besselI(x,\nu)\). Valid parameter range: \(x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}\). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This atomic function does not handle the derivative wrt. \(\nu\). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

</div>
</div>
<a id="af9f02597375de42ca19bcaeff3190938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f02597375de42ca19bcaeff3190938">&sect;&nbsp;</a></span>TMB_ATOMIC_VECTOR_FUNCTION() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_VECTOR_FUNCTION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CppAD::Integer(tx[0]) *CppAD::Integer(tx[1])&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typedef TypeDefs&lt; double &gt;::MapMatrix MapMatrix_t;typedef TypeDefs&lt; double &gt;::ConstMapMatrix ConstMapMatrix_t;int&#160;</td>
          <td class="paramname"><em>n1</em> = <code>CppAD::Integer(tx[0]);&#160;int&#160;n3&#160;=&#160;CppAD::Integer(tx[1]);&#160;int&#160;n2&#160;=&#160;(&#160;n1&#160;+&#160;n3&#160;&gt;&#160;0&#160;?&#160;(tx.size()&#160;-&#160;2)&#160;/&#160;(n1&#160;+&#160;n3)&#160;:&#160;0&#160;);&#160;ConstMapMatrix_t&#160;X(&amp;tx[2&#160;&#160;&#160;&#160;&#160;&#160;],&#160;n1,&#160;n2);&#160;ConstMapMatrix_t&#160;Y(&amp;tx[2+n1*n2],&#160;n2,&#160;n3);&#160;MapMatrix_t&#160;Z(&amp;ty[0&#160;&#160;&#160;&#160;&#160;&#160;],&#160;n1,&#160;n3);&#160;Z&#160;=&#160;X&#160;*&#160;Y;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typedef typename TypeDefs&lt; Type &gt;::MapMatrix MapMatrix_t;int&#160;</td>
          <td class="paramname"><em>n1</em> = <code>CppAD::Integer(tx[0]);&#160;int&#160;n3&#160;=&#160;CppAD::Integer(tx[1]);&#160;int&#160;n2&#160;=&#160;(&#160;n1&#160;+&#160;n3&#160;&gt;&#160;0&#160;?&#160;(tx.size()&#160;-&#160;2)&#160;/&#160;(n1&#160;+&#160;n3)&#160;:&#160;0&#160;);&#160;<a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt;&#160;Xt&#160;=&#160;vec2mat(tx,&#160;n1,&#160;n2,&#160;2).transpose();&#160;<a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt;&#160;Yt&#160;=&#160;vec2mat(tx,&#160;n2,&#160;n3,&#160;2&#160;+&#160;n1*n2).transpose();&#160;<a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt;&#160;W&#160;=&#160;vec2mat(py,&#160;n1,&#160;n3);&#160;MapMatrix_t&#160;res1(&amp;px[2&#160;&#160;&#160;&#160;&#160;&#160;],&#160;n1,&#160;n2);&#160;MapMatrix_t&#160;res2(&amp;px[2+n1*n2],&#160;n2,&#160;n3);&#160;res1&#160;=&#160;<a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>(W,&#160;Yt);&#160;&#160;res2&#160;=&#160;<a class="el" href="group__matrix__functions.html#ga481538cdd18f419396ee65eaec62c0ba">matmul</a>(Xt,&#160;W);&#160;&#160;px[0]&#160;=&#160;0;&#160;px[1]&#160;=&#160;0;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2+n1*n2+n2*n3 containing the output dimension (length=2), the first matrix (length=n1*n2) and the second matrix (length=n2*n3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n1*n3 containing result of matrix multiplication.Atomic version of matrix inversion. Inverts n-by-n matrix by LU-decomposition. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n*n. </dd></dl>

</div>
</div>
<a id="a7215bba00f5e746637c35e56e66be2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7215bba00f5e746637c35e56e66be2cf">&sect;&nbsp;</a></span>TMB_ATOMIC_VECTOR_FUNCTION() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic::TMB_ATOMIC_VECTOR_FUNCTION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matrix__functions.html#gae5555ee5c905915a566d47d7f2830424">logdet</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>sqrt((double)tx.size());&#160;<a class="el" href="structmatrix.html">matrix</a>&lt;double&gt;&#160;X=vec2mat(tx,n,n);&#160;<a class="el" href="structmatrix.html">matrix</a>&lt;double&gt;&#160;LU=X.lu().matrixLU();&#160;&#160;<a class="el" href="structvector.html">vector</a>&lt;double&gt;&#160;LUdiag&#160;=&#160;LU.diagonal();&#160;double&#160;res=LUdiag.abs().log().<a class="el" href="convenience_8hpp.html#a1fe3cb777e8fd8080385579ab87600e3">sum</a>();&#160;&#160;ty[0]&#160;=&#160;res;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>invX</em> = <code><a class="el" href="group__matrix__functions.html#gacf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a>(tx);&#160;for(size_t&#160;i=0;&#160;i&lt;tx.size();&#160;i++)&#160;px[i]&#160;=&#160;invX[i]&#160;*&#160;py[0];</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of log determinant of positive definite n-by-n matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1.Atomic version of log determinant <em>and</em> inverse of positive definite n-by-n matrix. Calculated by Cholesky decomposition. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1+n*n. </dd></dl>

</div>
</div>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
